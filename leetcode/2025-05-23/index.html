<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>LeetCode Daily Question 2025-05-23 | TzJ&#39;s Net</title>
<meta name="keywords" content="LeetCode, Daily Question, Solution, python, DP, Tree, Xor, Greedy, Trick, Hard">
<meta name="description" content="Solution to 3068. Find the Maximum Sum of Node Values">
<meta name="author" content="">
<link rel="canonical" href="https://tzj2006.github.io/leetcode/2025-05-23/">

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <meta name="referrer" content="no-referrer-when-downgrade">
<link crossorigin="anonymous" href="https://tzj2006.github.io/assets/css/stylesheet.af858c2feef42adc7846f815c3e21de9982d82f8fc4f65879451b2686859975a.css" integrity="sha256-r4WML&#43;70Ktx4RvgVw&#43;Id6Zgtgvj8T2WHlFGyaGhZl1o=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://tzj2006.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://tzj2006.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://tzj2006.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://tzj2006.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://tzj2006.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://tzj2006.github.io/leetcode/2025-05-23/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<script type="text/javascript" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>


<script src="https://tzj2006.github.io/js/checkbox-state.min.481208bf28be32dd7419d90065130144ba9a464a94857de0dc07fd19d3f2f6f3.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css" integrity="sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ" crossorigin="anonymous">

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js" integrity="sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY" crossorigin="anonymous"></script>

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>


<script>
document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
        delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "$", right: "$", display: false}
        ]
    });
});
</script>
<meta property="og:url" content="https://tzj2006.github.io/leetcode/2025-05-23/">
  <meta property="og:site_name" content="TzJ&#39;s Net">
  <meta property="og:title" content="LeetCode Daily Question 2025-05-23">
  <meta property="og:description" content="Solution to 3068. Find the Maximum Sum of Node Values">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="leetcode">
    <meta property="article:published_time" content="2025-05-23T21:16:05+08:00">
    <meta property="article:modified_time" content="2025-05-23T21:16:05+08:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeetCode Daily Question 2025-05-23">
<meta name="twitter:description" content="Solution to 3068. Find the Maximum Sum of Node Values">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Leetcodes",
      "item": "https://tzj2006.github.io/leetcode/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "LeetCode Daily Question 2025-05-23",
      "item": "https://tzj2006.github.io/leetcode/2025-05-23/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "LeetCode Daily Question 2025-05-23",
  "name": "LeetCode Daily Question 2025-05-23",
  "description": "Solution to 3068. Find the Maximum Sum of Node Values",
  "keywords": [
    "LeetCode", "Daily Question", "Solution", "python", "DP", "Tree", "Xor", "Greedy", "Trick", "Hard"
  ],
  "articleBody": "Today’s problem 3068. Find the Maximum Sum of Node Values\nImportant: all the methods below are based on this fact: xor even times equals xor zero times. Method 1: Tree DP Intuition and Approach In this problem, if we only consider one direction, e.g., from root to leaf, then the process will not have after effect (later decisions will not affect previous ones). Therefore, we can use DP to solve this problem.\nThe hardest part is the definition of the dp. As we have a prerequisite of a direction, a better way to define the dp formula is to exclude the effect of current node. Also, for each node, there are two status, as described above, each node can either xor odd times or even times.\nTherefore, we have our DP definition. $dp[x][0/1]$ means the largest value the children of x can achieve when the node x is changed (1) or unchanged (0).\nNow, for each child c of node x, we can do two operations: either do xor for both node x and c, or do not do xor for neither x nor c.\nThe dp formula of these two operations will be: (Note: the priority of $\\oplus$ is lower than $+$, so it is very important to add a parentheses.)\nDo the xor operation $dp[x][0] = max(dp[x][0] + dp[c][0] + nums[c], dp[x][0] + dp[c][1] + (nums[c] \\oplus k))$. $dp[x][1] = max(dp[x][1] + dp[c][0] + nums[c], dp[x][1] + dp[c][1] + (nums[c] \\oplus k))$. NOT do the xor operation $dp[x][0] = max(dp[x][1] + dp[c][1] + nums[c], dp[x][1] + dp[c][0] + (nums[c] \\oplus k))$. $dp[x][1] = max(dp[x][0] + dp[c][0] + nums[c], dp[x][0] + dp[c][0] + (nums[c] \\oplus k))$. Note that the dp[x][0] and dp[x][1] should be renewed at the same time.\nMoreover, another important thing is the initialization of the dp array. For all $dp[x][1]$, we will give it a value of $-inf$, so that we can avoid the case when c is a leaf node and the number is $\\oplus$ with k contributes to the $dp[x]$ array.\nThe final result will be $max((dp[0][0] + nums[0]), (dp[0][1] + (nums[0] ^ k)))$\nComplexity Time complexity: $O(N)$, N is the length of nums. Space complexity: $O(N)$, N is the length of nums. Code class Solution: def maximumValueSum(self, nums: List[int], k: int, edges: List[List[int]]) -\u003e int: n = len(nums) dp = [[0 for _ in range(2)] for _ in range(n)] for i in range(n): dp[i][1] = -10_000_000_000 edge = [[] for _ in range(n)] for x,y in edges: edge[x].append(y) edge[y].append(x) def dfs(x, fa): for to in edge[x]: if to == fa: continue dfs(to, x) c0 = max(dp[to][0] + nums[to], dp[to][1] + (nums[to] ^ k)) c1 = max(dp[to][0] + (nums[to] ^ k), dp[to][1] + nums[to]) dp[x][0], dp[x][1] = max(dp[x][0] + c0, dp[x][1] + c1), max(dp[x][1] + c0, dp[x][0] + c1) dfs(0,-1) return max((dp[0][0] + nums[0]), (dp[0][1] + (nums[0] ^ k))) Method 2: Tree DP with better memory Intuition and Approach In the previous code, we find that the $dp[x]$ will only use two times. Once in calculating the result of $dp[x]$, once in calculating the result of $dp[fa]$.\nTherefore, we can return the value of $dp[x][0]$ and $dp[x][1]$ to avoid the extra space of the dp array.\nComplexity Time complexity: $O(N)$, N is the length of nums. Space complexity: $O(1)$. Code class Solution: def maximumValueSum(self, nums: List[int], k: int, edges: List[List[int]]) -\u003e int: n = len(nums) edge = [[] for _ in range(n)] for x,y in edges: edge[x].append(y) edge[y].append(x) def dfs(x, fa): dp0,dp1 = 0,-1e9 for to in edge[x]: if to == fa: continue c0, c1 = dfs(to, x) dp0, dp1 = max(dp0 + c0, dp1 + c1), max(dp0 + c1, dp1 + c0) return max(dp0 + nums[x], dp1 + (nums[x] ^ k)), max(dp0 + (nums[x] ^ k), dp1 + nums[x]) return dfs(0,-1)[0] Important: all the methods below are based on this fact: there are always a path between two nodes on a tree. Therefore, we can $\\oplus$ all the nodes on this path, resulting the $\\oplus$ of any two nodes on the tree. Method 3: DP without tree Intuition and Approach For each node, we have two status, whether to $\\oplus$ k or not. Therefore, the definition of the DP array will be: $dp[i][0/1]$ means whether there are odd (1) or even (0) $\\oplus$ k operations when traversing to the ith node.\nWe then have the formular:\nWhen this node $\\oplus$ with k: $dp[i][0] = max(dp[i-1][0] + nums[i], dp[i-1][1] + (nums[i] ^ k))$ When this node do not $\\oplus$ with k: $dp[i][1] = max(dp[i-1][1] + nums[i], dp[i-1][0] + (nums[i] ^ k))$ Note that there are always even $\\oplus$ operations, so the answer would be $dp[n-1][0]$.\nComplexity Time complexity: $O(N)$, N is the length of nums. Space complexity: $O(N)$, N is the length of nums. Code class Solution: def maximumValueSum(self, nums: List[int], k: int, edges: List[List[int]]) -\u003e int: n = len(nums) dp = [[0 for _ in range(2)] for _ in range(n)] dp[0][0] = nums[0] dp[0][1] = (nums[0] ^ k) for i in range(1, n): dp[i][0] = max(dp[i-1][0] + nums[i], dp[i-1][1] + (nums[i] ^ k)) dp[i][1] = max(dp[i-1][0] + (nums[i] ^ k), dp[i-1][1] + nums[i]) return dp[-1][0] Method 4: DP without tree with better memory Intuition and Approach Same as Method 2, we also find out that the dp[i] formular only use twice. In this case, we can use two variables instead of the whold array to have a better memory usage.\nAlso, the $max$ operations is too slow in python, so a better way is to use if else equations instead of max.\nComplexity Time complexity: $O(N)$, N is the length of nums. Space complexity: $O(1)$. Code class Solution: def maximumValueSum(self, nums: List[int], k: int, edges: List[List[int]]) -\u003e int: n = len(nums) dp0, dp1 = 0, -10_000_000_000 for i in range(n): a = nums[i] b = a ^ k new_dp0 = dp0 + a if dp0 + a \u003e dp1 + b else dp1 + b new_dp1 = dp0 + b if dp0 + b \u003e dp1 + a else dp1 + a dp0, dp1 = new_dp0, new_dp1 return dp0 Method 5: Greedy algorithm Intuition and Approach Another way to look at this method without of tree is using greedy algorithm. Because we know that we can $\\oplus$ k as long as we can find a pair of nodes, we can use greedy algorithm to find the pairs that has the most differences after $\\oplus$ k.\nThat is, we can first $\\oplus$ every element with k, calculating the difference between the new array and the previous array, then find all the pairs that has a difference that is larger than zero, then we get our answer.\nComplexity Time complexity: $O(N)$, N is the length of nums. Space complexity: $O(N)$, N is the length of nums. Code class Solution: def maximumValueSum(self, nums: List[int], k: int, edges: List[List[int]]) -\u003e int: ans = sum(nums) diff = [(x ^ k) - x for x in nums] cnt,l,r = 0,inf,-inf for x in diff: if x \u003e 0: cnt += 1 if x \u003c l: l = x ans += x else: if r \u003c x: r = x if cnt % 2 == 1: ans += max(-l, r) return ans I don’t know why using sort to do greedy algorithm is so neat and fast. Just as the one in the official solution.\nAdvertisement For more solutions, please visit My blog\n",
  "wordCount" : "1223",
  "inLanguage": "en",
  "datePublished": "2025-05-23T21:16:05+08:00",
  "dateModified": "2025-05-23T21:16:05+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://tzj2006.github.io/leetcode/2025-05-23/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "TzJ's Net",
    "logo": {
      "@type": "ImageObject",
      "url": "https://tzj2006.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://tzj2006.github.io/" accesskey="h" title="TzJ&#39;s Net (Alt + H)">TzJ&#39;s Net</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://tzj2006.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://tzj2006.github.io/bugjournal/" title="bugJournal">
                    <span>bugJournal</span>
                </a>
            </li>
            <li>
                <a href="https://tzj2006.github.io/leetcode/" title="leetcode">
                    <span>leetcode</span>
                </a>
            </li>
            <li>
                <a href="https://tzj2006.github.io/posts/" title="posts &amp; notes">
                    <span>posts &amp; notes</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://tzj2006.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://tzj2006.github.io/leetcode/">Leetcodes</a></div>
    <h1 class="post-title entry-hint-parent">
      LeetCode Daily Question 2025-05-23
    </h1>
    <div class="post-description">
      Solution to 3068. Find the Maximum Sum of Node Values
    </div>
    <div class="post-meta"><span title='2025-05-23 21:16:05 +0800 +0800'>May 23, 2025</span>&nbsp;·&nbsp;6 min


      
      <div class="meta-item">
        <span id="busuanzi_container_page_pv">
           &nbsp; People Read: <span id="busuanzi_value_page_pv"></span>
        </span>
     </div>

    </div>
  </header> 
  <div class="post-content"><h1 id="todays-problem">Today&rsquo;s problem<a hidden class="anchor" aria-hidden="true" href="#todays-problem">#</a></h1>
<p><a href="https://leetcode.com/problems/find-the-maximum-sum-of-node-values/">3068. Find the Maximum Sum of Node Values</a></p>
<h2 id="important-all-the-methods-below-are-based-on-this-fact-xor-even-times-equals-xor-zero-times"><strong>Important:</strong> all the methods below are based on this fact: xor even times equals xor zero times.<a hidden class="anchor" aria-hidden="true" href="#important-all-the-methods-below-are-based-on-this-fact-xor-even-times-equals-xor-zero-times">#</a></h2>
<h2 id="method-1-tree-dp">Method 1: Tree DP<a hidden class="anchor" aria-hidden="true" href="#method-1-tree-dp">#</a></h2>
<h3 id="intuition-and-approach">Intuition and Approach<a hidden class="anchor" aria-hidden="true" href="#intuition-and-approach">#</a></h3>
<!-- Describe your first thoughts on how to solve this problem. -->
<p>In this problem, if we only consider one direction, e.g., from root to leaf, then the process will not have after effect (later decisions will not affect previous ones). Therefore, we can use DP to solve this problem.</p>
<p>The hardest part is the definition of the dp. As we have a prerequisite of a direction, a better way to define the dp formula is to exclude the effect of current node. Also, for each node, there are two status, as described above, each node can either xor odd times or even times.</p>
<p>Therefore, we have our DP definition.
$dp[x][0/1]$ means the largest value the <strong>children</strong> of x can achieve when the node x is changed (1) or unchanged (0).</p>
<p>Now, for each child c of node x, we can do two operations: either do xor for both node x and c, or do not do xor for neither x nor c.</p>
<p>The dp formula of these two operations will be:
(Note: the priority of $\oplus$ is lower than $+$, so it is very important to add a parentheses.)</p>
<ul>
<li>Do the xor operation
$dp[x][0] = max(dp[x][0] + dp[c][0] + nums[c], dp[x][0] + dp[c][1] + (nums[c] \oplus k))$.
$dp[x][1] = max(dp[x][1] + dp[c][0] + nums[c], dp[x][1] + dp[c][1] + (nums[c] \oplus k))$.</li>
<li>NOT do the xor operation
$dp[x][0] = max(dp[x][1] + dp[c][1] + nums[c], dp[x][1] + dp[c][0] + (nums[c] \oplus k))$.
$dp[x][1] = max(dp[x][0] + dp[c][0] + nums[c], dp[x][0] + dp[c][0] + (nums[c] \oplus k))$.</li>
</ul>
<p><strong>Note that the dp[x][0] and dp[x][1] should be renewed at the same time.</strong></p>
<p>Moreover, another important thing is the initialization of the dp array. For all $dp[x][1]$, we will give it a value of $-inf$, so that we can avoid the case when c is a leaf node and the number is $\oplus$ with k contributes to the $dp[x]$ array.</p>
<p>The final result will be $max((dp[0][0] + nums[0]), (dp[0][1] + (nums[0] ^ k)))$</p>
<h3 id="complexity">Complexity<a hidden class="anchor" aria-hidden="true" href="#complexity">#</a></h3>
<ul>
<li>Time complexity: $O(N)$, N is the length of nums.</li>
</ul>
<!-- Add your time complexity here, e.g. $$O(n)$$ -->
<ul>
<li>Space complexity: $O(N)$, N is the length of nums.</li>
</ul>
<!-- Add your space complexity here, e.g. $$O(n)$$ -->
<h3 id="code">Code<a hidden class="anchor" aria-hidden="true" href="#code">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">maximumValueSum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">edges</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">dp</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">10_000_000_000</span>
</span></span><span class="line"><span class="cl">      
</span></span><span class="line"><span class="cl">        <span class="n">edge</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">edge</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">edge</span><span class="p">[</span><span class="n">y</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">fa</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="n">to</span> <span class="ow">in</span> <span class="n">edge</span><span class="p">[</span><span class="n">x</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="n">to</span> <span class="o">==</span> <span class="n">fa</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                    <span class="k">continue</span>
</span></span><span class="line"><span class="cl">                <span class="n">dfs</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="n">c0</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">to</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">to</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">to</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">to</span><span class="p">]</span> <span class="o">^</span> <span class="n">k</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                <span class="n">c1</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">to</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">to</span><span class="p">]</span> <span class="o">^</span> <span class="n">k</span><span class="p">),</span> <span class="n">dp</span><span class="p">[</span><span class="n">to</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">to</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">                <span class="n">dp</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">c0</span><span class="p">,</span> <span class="n">dp</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">c1</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">c0</span><span class="p">,</span> <span class="n">dp</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">c1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      
</span></span><span class="line"><span class="cl">        <span class="n">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">max</span><span class="p">((</span><span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">^</span> <span class="n">k</span><span class="p">)))</span>
</span></span></code></pre></div><p><img alt="image.png" loading="lazy" src="https://assets.leetcode.com/users/images/05e979d6-6cbd-4950-b34c-ba3eb97d3c73_1748006766.226214.png"></p>
<h2 id="method-2-tree-dp-with-better-memory">Method 2: Tree DP with better memory<a hidden class="anchor" aria-hidden="true" href="#method-2-tree-dp-with-better-memory">#</a></h2>
<h3 id="intuition-and-approach-1">Intuition and Approach<a hidden class="anchor" aria-hidden="true" href="#intuition-and-approach-1">#</a></h3>
<p>In the previous code, we find that the $dp[x]$ will only use two times. Once in calculating the result of $dp[x]$, once in calculating the result of $dp[fa]$.</p>
<p>Therefore, we can return the value of $dp[x][0]$ and $dp[x][1]$ to avoid the extra space of the dp array.</p>
<h3 id="complexity-1">Complexity<a hidden class="anchor" aria-hidden="true" href="#complexity-1">#</a></h3>
<ul>
<li>Time complexity: $O(N)$, N is the length of nums.</li>
</ul>
<!-- Add your time complexity here, e.g. $$O(n)$$ -->
<ul>
<li>Space complexity: $O(1)$.</li>
</ul>
<!-- Add your space complexity here, e.g. $$O(n)$$ -->
<h3 id="code-1">Code<a hidden class="anchor" aria-hidden="true" href="#code-1">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">maximumValueSum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">edges</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">edge</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">edge</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">edge</span><span class="p">[</span><span class="n">y</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">fa</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">            <span class="n">dp0</span><span class="p">,</span><span class="n">dp1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mf">1e9</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="n">to</span> <span class="ow">in</span> <span class="n">edge</span><span class="p">[</span><span class="n">x</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="n">to</span> <span class="o">==</span> <span class="n">fa</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                    <span class="k">continue</span>
</span></span><span class="line"><span class="cl">                <span class="n">c0</span><span class="p">,</span> <span class="n">c1</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="n">dp0</span><span class="p">,</span> <span class="n">dp1</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp0</span> <span class="o">+</span> <span class="n">c0</span><span class="p">,</span> <span class="n">dp1</span> <span class="o">+</span> <span class="n">c1</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp0</span> <span class="o">+</span> <span class="n">c1</span><span class="p">,</span> <span class="n">dp1</span> <span class="o">+</span> <span class="n">c0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">          
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp0</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">dp1</span> <span class="o">+</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">^</span> <span class="n">k</span><span class="p">)),</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp0</span> <span class="o">+</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">^</span> <span class="n">k</span><span class="p">),</span> <span class="n">dp1</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">      
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
</span></span></code></pre></div><p><img alt="image.png" loading="lazy" src="https://assets.leetcode.com/users/images/f5bd6cf2-e868-4858-abb7-0a152aadcca7_1748009096.4479992.png"></p>
<h2 id="important-all-the-methods-below-are-based-on-this-fact-there-are-always-a-path-between-two-nodes-on-a-tree-therefore-we-can-oplus-all-the-nodes-on-this-path-resulting-the-oplus-of-any-two-nodes-on-the-tree"><strong>Important:</strong> all the methods below are based on this fact: there are always a path between two nodes on a tree. Therefore, we can $\oplus$ all the nodes on this path, resulting the $\oplus$ of any two nodes on the tree.<a hidden class="anchor" aria-hidden="true" href="#important-all-the-methods-below-are-based-on-this-fact-there-are-always-a-path-between-two-nodes-on-a-tree-therefore-we-can-oplus-all-the-nodes-on-this-path-resulting-the-oplus-of-any-two-nodes-on-the-tree">#</a></h2>
<h2 id="method-3-dp-without-tree">Method 3: DP without tree<a hidden class="anchor" aria-hidden="true" href="#method-3-dp-without-tree">#</a></h2>
<h3 id="intuition-and-approach-2">Intuition and Approach<a hidden class="anchor" aria-hidden="true" href="#intuition-and-approach-2">#</a></h3>
<p>For each node, we have two status, whether to $\oplus$ k or not. Therefore, the definition of the DP array will be:
$dp[i][0/1]$ means whether there are odd (1) or even (0) $\oplus$ k operations when traversing to the ith node.</p>
<p>We then have the formular:</p>
<ul>
<li>When this node $\oplus$ with k:
$dp[i][0] = max(dp[i-1][0] + nums[i], dp[i-1][1] + (nums[i] ^ k))$</li>
<li>When this node do not $\oplus$ with k:
$dp[i][1] = max(dp[i-1][1] + nums[i], dp[i-1][0] + (nums[i] ^ k))$</li>
</ul>
<p>Note that there are always even $\oplus$ operations, so the answer would be $dp[n-1][0]$.</p>
<h3 id="complexity-2">Complexity<a hidden class="anchor" aria-hidden="true" href="#complexity-2">#</a></h3>
<ul>
<li>Time complexity: $O(N)$, N is the length of nums.</li>
</ul>
<!-- Add your time complexity here, e.g. $$O(n)$$ -->
<ul>
<li>Space complexity: $O(N)$, N is the length of nums.</li>
</ul>
<!-- Add your space complexity here, e.g. $$O(n)$$ -->
<h3 id="code-2">Code<a hidden class="anchor" aria-hidden="true" href="#code-2">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">maximumValueSum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">edges</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">dp</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
</span></span><span class="line"><span class="cl">        <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">^</span> <span class="n">k</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^</span> <span class="n">k</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^</span> <span class="n">k</span><span class="p">),</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
</span></span></code></pre></div><p><img alt="image.png" loading="lazy" src="https://assets.leetcode.com/users/images/23dda70d-642f-417d-a8e3-c682877d0d29_1748008274.1083493.png"></p>
<h2 id="method-4-dp-without-tree-with-better-memory">Method 4: DP without tree with better memory<a hidden class="anchor" aria-hidden="true" href="#method-4-dp-without-tree-with-better-memory">#</a></h2>
<h3 id="intuition-and-approach-3">Intuition and Approach<a hidden class="anchor" aria-hidden="true" href="#intuition-and-approach-3">#</a></h3>
<p>Same as Method 2, we also find out that the dp[i] formular only use twice. In this case, we can use two variables instead of the whold array to have a better memory usage.</p>
<p>Also, the $max$ operations is too slow in python, so a better way is to use if else equations instead of max.</p>
<h3 id="complexity-3">Complexity<a hidden class="anchor" aria-hidden="true" href="#complexity-3">#</a></h3>
<ul>
<li>Time complexity: $O(N)$, N is the length of nums.</li>
</ul>
<!-- Add your time complexity here, e.g. $$O(n)$$ -->
<ul>
<li>Space complexity: $O(1)$.</li>
</ul>
<!-- Add your space complexity here, e.g. $$O(n)$$ -->
<h3 id="code-3">Code<a hidden class="anchor" aria-hidden="true" href="#code-3">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">maximumValueSum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">edges</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">dp0</span><span class="p">,</span> <span class="n">dp1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">10_000_000_000</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">            <span class="n">a</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">            <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">^</span> <span class="n">k</span>
</span></span><span class="line"><span class="cl">            <span class="n">new_dp0</span> <span class="o">=</span> <span class="n">dp0</span> <span class="o">+</span> <span class="n">a</span> <span class="k">if</span> <span class="n">dp0</span> <span class="o">+</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">dp1</span> <span class="o">+</span> <span class="n">b</span> <span class="k">else</span> <span class="n">dp1</span> <span class="o">+</span> <span class="n">b</span>
</span></span><span class="line"><span class="cl">            <span class="n">new_dp1</span> <span class="o">=</span> <span class="n">dp0</span> <span class="o">+</span> <span class="n">b</span> <span class="k">if</span> <span class="n">dp0</span> <span class="o">+</span> <span class="n">b</span> <span class="o">&gt;</span> <span class="n">dp1</span> <span class="o">+</span> <span class="n">a</span> <span class="k">else</span> <span class="n">dp1</span> <span class="o">+</span> <span class="n">a</span>
</span></span><span class="line"><span class="cl">            <span class="n">dp0</span><span class="p">,</span> <span class="n">dp1</span> <span class="o">=</span> <span class="n">new_dp0</span><span class="p">,</span> <span class="n">new_dp1</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">dp0</span>
</span></span></code></pre></div><p><img alt="image.png" loading="lazy" src="https://assets.leetcode.com/users/images/08dd065f-d575-4184-a1cb-27b4a7855c66_1748008335.8503327.png"></p>
<h2 id="method-5-greedy-algorithm">Method 5: Greedy algorithm<a hidden class="anchor" aria-hidden="true" href="#method-5-greedy-algorithm">#</a></h2>
<h3 id="intuition-and-approach-4">Intuition and Approach<a hidden class="anchor" aria-hidden="true" href="#intuition-and-approach-4">#</a></h3>
<p>Another way to look at this method without of tree is using greedy algorithm. Because we know that we can $\oplus$ k as long as we can find a pair of nodes, we can use greedy algorithm to find the pairs that has the most differences after $\oplus$ k.</p>
<p>That is, we can first $\oplus$ every element with k, calculating the difference between the new array and the previous array, then find all the pairs that has a difference that is larger than zero, then we get our answer.</p>
<h3 id="complexity-4">Complexity<a hidden class="anchor" aria-hidden="true" href="#complexity-4">#</a></h3>
<ul>
<li>Time complexity: $O(N)$, N is the length of nums.</li>
</ul>
<!-- Add your time complexity here, e.g. $$O(n)$$ -->
<ul>
<li>Space complexity: $O(N)$, N is the length of nums.</li>
</ul>
<!-- Add your space complexity here, e.g. $$O(n)$$ -->
<h3 id="code-4">Code<a hidden class="anchor" aria-hidden="true" href="#code-4">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python3" data-lang="python3"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">maximumValueSum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">edges</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">ans</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">diff</span> <span class="o">=</span> <span class="p">[(</span><span class="n">x</span> <span class="o">^</span> <span class="n">k</span><span class="p">)</span> <span class="o">-</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="n">cnt</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span><span class="n">inf</span><span class="p">,</span><span class="o">-</span><span class="n">inf</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">diff</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">l</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                    <span class="n">l</span> <span class="o">=</span> <span class="n">x</span>
</span></span><span class="line"><span class="cl">                <span class="n">ans</span> <span class="o">+=</span> <span class="n">x</span>
</span></span><span class="line"><span class="cl">            <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                    <span class="n">r</span> <span class="o">=</span> <span class="n">x</span>
</span></span><span class="line"><span class="cl">      
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">cnt</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">ans</span> <span class="o">+=</span> <span class="nb">max</span><span class="p">(</span><span class="o">-</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">ans</span>
</span></span></code></pre></div><p><img alt="image.png" loading="lazy" src="https://assets.leetcode.com/users/images/dfc623ee-41bc-4319-b318-a0721f49cdc9_1748008909.2892299.png"></p>
<p><del>I don&rsquo;t know why using sort to do greedy algorithm is so neat and fast. Just as the one in the official solution.</del></p>
<h2 id="advertisement">Advertisement<a hidden class="anchor" aria-hidden="true" href="#advertisement">#</a></h2>
<p>For more solutions, please visit <a href="tzj2006.github.io/leetcode">My blog</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://tzj2006.github.io/">TzJ&#39;s Net</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
    <span>
        · 本站访客数：<span id="busuanzi_value_site_uv"></span>
        · 总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
    
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
